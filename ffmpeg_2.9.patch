Description: Replace deprecated FFmpeg API
Author: Andreas Cadhalpun <Andreas.Cadhalpun@googlemail.com>
Last-Update: <2015-11-02>

--- vlc-2.2.1.orig/modules/codec/avcodec/audio.c
+++ vlc-2.2.1/modules/codec/avcodec/audio.c
@@ -39,7 +39,7 @@
 #include <libavcodec/avcodec.h>
 #include <libavutil/mem.h>
 
-#include <libavutil/audioconvert.h>
+#include <libavutil/channel_layout.h>
 
 #include "avcodec.h"
 
--- vlc-2.2.1.orig/modules/codec/avcodec/chroma.c
+++ vlc-2.2.1/modules/codec/avcodec/chroma.c
@@ -62,77 +62,77 @@ static const struct
 } chroma_table[] =
 {
     /* Planar YUV formats */
-    {VLC_CODEC_I444, PIX_FMT_YUV444P, 0, 0, 0 },
-    {VLC_CODEC_J444, PIX_FMT_YUVJ444P, 0, 0, 0 },
+    {VLC_CODEC_I444, AV_PIX_FMT_YUV444P, 0, 0, 0 },
+    {VLC_CODEC_J444, AV_PIX_FMT_YUVJ444P, 0, 0, 0 },
 
-    {VLC_CODEC_I440, PIX_FMT_YUV440P, 0, 0, 0 },
-    {VLC_CODEC_J440, PIX_FMT_YUVJ440P, 0, 0, 0 },
+    {VLC_CODEC_I440, AV_PIX_FMT_YUV440P, 0, 0, 0 },
+    {VLC_CODEC_J440, AV_PIX_FMT_YUVJ440P, 0, 0, 0 },
 
-    {VLC_CODEC_I422, PIX_FMT_YUV422P, 0, 0, 0 },
-    {VLC_CODEC_J422, PIX_FMT_YUVJ422P, 0, 0, 0 },
+    {VLC_CODEC_I422, AV_PIX_FMT_YUV422P, 0, 0, 0 },
+    {VLC_CODEC_J422, AV_PIX_FMT_YUVJ422P, 0, 0, 0 },
 
-    {VLC_CODEC_I420, PIX_FMT_YUV420P, 0, 0, 0 },
-    {VLC_CODEC_YV12, PIX_FMT_YUV420P, 0, 0, 0 },
-    {VLC_FOURCC('I','Y','U','V'), PIX_FMT_YUV420P, 0, 0, 0 },
-    {VLC_CODEC_J420, PIX_FMT_YUVJ420P, 0, 0, 0 },
-    {VLC_CODEC_I411, PIX_FMT_YUV411P, 0, 0, 0 },
-    {VLC_CODEC_I410, PIX_FMT_YUV410P, 0, 0, 0 },
-    {VLC_FOURCC('Y','V','U','9'), PIX_FMT_YUV410P, 0, 0, 0 },
-
-    {VLC_FOURCC('N','V','1','2'), PIX_FMT_NV12, 0, 0, 0 },
-    {VLC_FOURCC('N','V','2','1'), PIX_FMT_NV21, 0, 0, 0 },
-
-    {VLC_CODEC_I420_9L, PIX_FMT_YUV420P9LE, 0, 0, 0 },
-    {VLC_CODEC_I420_9B, PIX_FMT_YUV420P9BE, 0, 0, 0 },
-    {VLC_CODEC_I420_10L, PIX_FMT_YUV420P10LE, 0, 0, 0 },
-    {VLC_CODEC_I420_10B, PIX_FMT_YUV420P10BE, 0, 0, 0 },
+    {VLC_CODEC_I420, AV_PIX_FMT_YUV420P, 0, 0, 0 },
+    {VLC_CODEC_YV12, AV_PIX_FMT_YUV420P, 0, 0, 0 },
+    {VLC_FOURCC('I','Y','U','V'), AV_PIX_FMT_YUV420P, 0, 0, 0 },
+    {VLC_CODEC_J420, AV_PIX_FMT_YUVJ420P, 0, 0, 0 },
+    {VLC_CODEC_I411, AV_PIX_FMT_YUV411P, 0, 0, 0 },
+    {VLC_CODEC_I410, AV_PIX_FMT_YUV410P, 0, 0, 0 },
+    {VLC_FOURCC('Y','V','U','9'), AV_PIX_FMT_YUV410P, 0, 0, 0 },
+
+    {VLC_FOURCC('N','V','1','2'), AV_PIX_FMT_NV12, 0, 0, 0 },
+    {VLC_FOURCC('N','V','2','1'), AV_PIX_FMT_NV21, 0, 0, 0 },
+
+    {VLC_CODEC_I420_9L, AV_PIX_FMT_YUV420P9LE, 0, 0, 0 },
+    {VLC_CODEC_I420_9B, AV_PIX_FMT_YUV420P9BE, 0, 0, 0 },
+    {VLC_CODEC_I420_10L, AV_PIX_FMT_YUV420P10LE, 0, 0, 0 },
+    {VLC_CODEC_I420_10B, AV_PIX_FMT_YUV420P10BE, 0, 0, 0 },
 #if LIBAVUTIL_VERSION_INT >= AV_VERSION_INT(51,13,0)
-    {VLC_CODEC_I422_9L, PIX_FMT_YUV422P9LE, 0, 0, 0 },
-    {VLC_CODEC_I422_9B, PIX_FMT_YUV422P9BE, 0, 0, 0 },
+    {VLC_CODEC_I422_9L, AV_PIX_FMT_YUV422P9LE, 0, 0, 0 },
+    {VLC_CODEC_I422_9B, AV_PIX_FMT_YUV422P9BE, 0, 0, 0 },
 #endif
-    {VLC_CODEC_I422_10L, PIX_FMT_YUV422P10LE, 0, 0, 0 },
-    {VLC_CODEC_I422_10B, PIX_FMT_YUV422P10BE, 0, 0, 0 },
+    {VLC_CODEC_I422_10L, AV_PIX_FMT_YUV422P10LE, 0, 0, 0 },
+    {VLC_CODEC_I422_10B, AV_PIX_FMT_YUV422P10BE, 0, 0, 0 },
 
-    {VLC_CODEC_YUV420A, PIX_FMT_YUVA420P, 0, 0, 0 },
+    {VLC_CODEC_YUV420A, AV_PIX_FMT_YUVA420P, 0, 0, 0 },
 #if LIBAVUTIL_VERSION_CHECK( 51, 45, 0, 74, 100 )
     {VLC_CODEC_YUV422A, AV_PIX_FMT_YUVA422P, 0, 0, 0 },
 #endif
 
-    {VLC_CODEC_I444_9L, PIX_FMT_YUV444P9LE, 0, 0, 0 },
-    {VLC_CODEC_I444_9B, PIX_FMT_YUV444P9BE, 0, 0, 0 },
-    {VLC_CODEC_I444_10L, PIX_FMT_YUV444P10LE, 0, 0, 0 },
-    {VLC_CODEC_I444_10B, PIX_FMT_YUV444P10BE, 0, 0, 0 },
-    {VLC_CODEC_I444_16L, PIX_FMT_YUV444P16LE, 0, 0, 0 },
-    {VLC_CODEC_I444_16B, PIX_FMT_YUV444P16BE, 0, 0, 0 },
+    {VLC_CODEC_I444_9L, AV_PIX_FMT_YUV444P9LE, 0, 0, 0 },
+    {VLC_CODEC_I444_9B, AV_PIX_FMT_YUV444P9BE, 0, 0, 0 },
+    {VLC_CODEC_I444_10L, AV_PIX_FMT_YUV444P10LE, 0, 0, 0 },
+    {VLC_CODEC_I444_10B, AV_PIX_FMT_YUV444P10BE, 0, 0, 0 },
+    {VLC_CODEC_I444_16L, AV_PIX_FMT_YUV444P16LE, 0, 0, 0 },
+    {VLC_CODEC_I444_16B, AV_PIX_FMT_YUV444P16BE, 0, 0, 0 },
 
     /* Packed YUV formats */
-    {VLC_CODEC_YUYV, PIX_FMT_YUYV422, 0, 0, 0 },
-    {VLC_FOURCC('Y','U','Y','V'), PIX_FMT_YUYV422, 0, 0, 0 },
-    {VLC_CODEC_UYVY, PIX_FMT_UYVY422, 0, 0, 0 },
-    {VLC_FOURCC('Y','4','1','1'), PIX_FMT_UYYVYY411, 0, 0, 0 },
+    {VLC_CODEC_YUYV, AV_PIX_FMT_YUYV422, 0, 0, 0 },
+    {VLC_FOURCC('Y','U','Y','V'), AV_PIX_FMT_YUYV422, 0, 0, 0 },
+    {VLC_CODEC_UYVY, AV_PIX_FMT_UYVY422, 0, 0, 0 },
+    {VLC_FOURCC('Y','4','1','1'), AV_PIX_FMT_UYYVYY411, 0, 0, 0 },
 
     /* Packed RGB formats */
-    VLC_RGB( VLC_FOURCC('R','G','B','4'), PIX_FMT_RGB4, PIX_FMT_BGR4, 0x10, 0x06, 0x01 )
-    VLC_RGB( VLC_FOURCC('R','G','B','8'), PIX_FMT_RGB8, PIX_FMT_BGR8, 0xC0, 0x38, 0x07 )
+    VLC_RGB( VLC_FOURCC('R','G','B','4'), AV_PIX_FMT_RGB4, AV_PIX_FMT_BGR4, 0x10, 0x06, 0x01 )
+    VLC_RGB( VLC_FOURCC('R','G','B','8'), AV_PIX_FMT_RGB8, AV_PIX_FMT_BGR8, 0xC0, 0x38, 0x07 )
 
-    VLC_RGB( VLC_CODEC_RGB15, PIX_FMT_RGB555, PIX_FMT_BGR555, 0x7c00, 0x03e0, 0x001f )
-    VLC_RGB( VLC_CODEC_RGB16, PIX_FMT_RGB565, PIX_FMT_BGR565, 0xf800, 0x07e0, 0x001f )
-    VLC_RGB( VLC_CODEC_RGB24, PIX_FMT_BGR24, PIX_FMT_RGB24, 0xff0000, 0x00ff00, 0x0000ff )
+    VLC_RGB( VLC_CODEC_RGB15, AV_PIX_FMT_RGB555, AV_PIX_FMT_BGR555, 0x7c00, 0x03e0, 0x001f )
+    VLC_RGB( VLC_CODEC_RGB16, AV_PIX_FMT_RGB565, AV_PIX_FMT_BGR565, 0xf800, 0x07e0, 0x001f )
+    VLC_RGB( VLC_CODEC_RGB24, AV_PIX_FMT_BGR24, AV_PIX_FMT_RGB24, 0xff0000, 0x00ff00, 0x0000ff )
 
-    VLC_RGB( VLC_CODEC_RGB32, PIX_FMT_RGB32, PIX_FMT_BGR32, 0x00ff0000, 0x0000ff00, 0x000000ff )
-    VLC_RGB( VLC_CODEC_RGB32, PIX_FMT_RGB32_1, PIX_FMT_BGR32_1, 0xff000000, 0x00ff0000, 0x0000ff00 )
+    VLC_RGB( VLC_CODEC_RGB32, AV_PIX_FMT_RGB32, AV_PIX_FMT_BGR32, 0x00ff0000, 0x0000ff00, 0x000000ff )
+    VLC_RGB( VLC_CODEC_RGB32, AV_PIX_FMT_RGB32_1, AV_PIX_FMT_BGR32_1, 0xff000000, 0x00ff0000, 0x0000ff00 )
 
 #ifdef AV_PIX_FMT_0BGR32
     VLC_RGB( VLC_CODEC_RGB32, AV_PIX_FMT_0BGR32, AV_PIX_FMT_0RGB32, 0x000000ff, 0x0000ff00, 0x00ff0000 )
 #endif
 
-    {VLC_CODEC_RGBA, PIX_FMT_RGBA, 0, 0, 0 },
-    {VLC_CODEC_ARGB, PIX_FMT_ARGB, 0, 0, 0 },
-    {VLC_CODEC_BGRA, PIX_FMT_BGRA, 0, 0, 0 },
-    {VLC_CODEC_GREY, PIX_FMT_GRAY8, 0, 0, 0},
+    {VLC_CODEC_RGBA, AV_PIX_FMT_RGBA, 0, 0, 0 },
+    {VLC_CODEC_ARGB, AV_PIX_FMT_ARGB, 0, 0, 0 },
+    {VLC_CODEC_BGRA, AV_PIX_FMT_BGRA, 0, 0, 0 },
+    {VLC_CODEC_GREY, AV_PIX_FMT_GRAY8, 0, 0, 0},
 
      /* Paletized RGB */
-    {VLC_CODEC_RGBP, PIX_FMT_PAL8, 0, 0, 0},
+    {VLC_CODEC_RGBP, AV_PIX_FMT_PAL8, 0, 0, 0},
 
 #if LIBAVUTIL_VERSION_CHECK(51, 42, 0, 74,100)
     {VLC_CODEC_GBR_PLANAR, AV_PIX_FMT_GBRP, 0, 0, 0 },
@@ -197,5 +197,5 @@ int FindFfmpegChroma( vlc_fourcc_t fourc
     for( int i = 0; chroma_table[i].i_chroma != 0; i++ )
         if( chroma_table[i].i_chroma == fourcc )
             return chroma_table[i].i_chroma_id;
-    return PIX_FMT_NONE;
+    return AV_PIX_FMT_NONE;
 }
--- vlc-2.2.1.orig/modules/codec/avcodec/dxva2.c
+++ vlc-2.2.1/modules/codec/avcodec/dxva2.c
@@ -533,7 +533,7 @@ static int Open(vlc_va_t *va, AVCodecCon
 
     /* TODO print the hardware name/vendor for debugging purposes */
     va->description = DxDescribe(sys);
-    va->pix_fmt = PIX_FMT_DXVA2_VLD;
+    va->pix_fmt = AV_PIX_FMT_DXVA2_VLD;
     va->setup   = Setup;
     va->get     = Get;
     va->release = Release;
--- vlc-2.2.1.orig/modules/codec/avcodec/encoder.c
+++ vlc-2.2.1/modules/codec/avcodec/encoder.c
@@ -41,7 +41,7 @@
 #include <vlc_cpu.h>
 
 #include <libavcodec/avcodec.h>
-#include <libavutil/audioconvert.h>
+#include <libavutil/channel_layout.h>
 
 #include "avcodec.h"
 #include "avcommon.h"
@@ -54,8 +54,6 @@
 #define HURRY_UP_GUARD2 (300000)
 #define HURRY_UP_GUARD3 (100000)
 
-#define MAX_FRAME_DELAY (FF_MAX_B_FRAMES + 2)
-
 #define RAW_AUDIO_FRAME_SIZE (2048)
 
 /*****************************************************************************
@@ -273,7 +271,7 @@ int OpenEncoder( vlc_object_t *p_this )
     else if( !GetFfmpegCodec( p_enc->fmt_out.i_codec, &i_cat, &i_codec_id,
                              &psz_namecodec ) )
     {
-        if( FindFfmpegChroma( p_enc->fmt_out.i_codec ) == PIX_FMT_NONE )
+        if( FindFfmpegChroma( p_enc->fmt_out.i_codec ) == AV_PIX_FMT_NONE )
             return VLC_EGENERIC; /* handed chroma output */
 
         i_cat      = VIDEO_ES;
@@ -507,8 +505,7 @@ int OpenEncoder( vlc_object_t *p_this )
 
         if( p_sys->i_key_int > 0 )
             p_context->gop_size = p_sys->i_key_int;
-        p_context->max_b_frames =
-            VLC_CLIP( p_sys->i_b_frames, 0, FF_MAX_B_FRAMES );
+        p_context->max_b_frames = p_sys->i_b_frames;
         p_context->b_frame_strategy = 0;
         if( !p_context->max_b_frames  &&
             (  p_enc->fmt_out.i_codec == VLC_CODEC_MPGV ||
@@ -532,7 +529,7 @@ int OpenEncoder( vlc_object_t *p_this )
 
         if( p_codec->pix_fmts )
         {
-            const enum PixelFormat *p = p_codec->pix_fmts;
+            const enum AVPixelFormat *p = p_codec->pix_fmts;
             for( ; *p != -1; p++ )
             {
                 if( *p == p_context->pix_fmt ) break;
@@ -994,7 +991,7 @@ errmsg:
         }
     }
 
-    p_sys->frame = avcodec_alloc_frame();
+    p_sys->frame = av_frame_alloc();
     if( !p_sys->frame )
     {
         goto error;
@@ -1063,7 +1060,7 @@ static block_t *EncodeVideo( encoder_t *
     AVFrame *frame = NULL;
     if( likely(p_pict) ) {
         frame = p_sys->frame;
-        avcodec_get_frame_defaults( frame );
+        av_frame_unref( frame );
         for( i_plane = 0; i_plane < p_pict->i_planes; i_plane++ )
         {
             p_sys->frame->data[i_plane] = p_pict->p[i_plane].p_pixels;
@@ -1298,7 +1295,7 @@ static block_t *handle_delay_buffer( enc
     //How much we need to copy from new packet
     const int leftover = leftover_samples * p_sys->p_context->channels * p_sys->i_sample_bytes;
 
-    avcodec_get_frame_defaults( p_sys->frame );
+    av_frame_unref( p_sys->frame );
     p_sys->frame->format     = p_sys->p_context->sample_fmt;
     p_sys->frame->nb_samples = leftover_samples + p_sys->i_samples_delay;
 
@@ -1420,7 +1417,7 @@ static block_t *EncodeAudio( encoder_t *
     while( ( p_aout_buf->i_nb_samples >= p_sys->i_frame_size ) ||
            ( p_sys->b_variable && p_aout_buf->i_nb_samples ) )
     {
-        avcodec_get_frame_defaults( p_sys->frame );
+        av_frame_unref( p_sys->frame );
         if( p_sys->b_variable )
             p_sys->frame->nb_samples = p_aout_buf->i_nb_samples;
         else
@@ -1483,8 +1480,7 @@ void CloseEncoder( vlc_object_t *p_this
     encoder_t *p_enc = (encoder_t *)p_this;
     encoder_sys_t *p_sys = p_enc->p_sys;
 
-    /*FIXME: we should use avcodec_free_frame, but we don't require so new avcodec that has it*/
-    av_freep( &p_sys->frame );
+    av_frame_free( &p_sys->frame );
 
     vlc_avcodec_lock();
     avcodec_close( p_sys->p_context );
--- vlc-2.2.1.orig/modules/codec/avcodec/vaapi.c
+++ vlc-2.2.1/modules/codec/avcodec/vaapi.c
@@ -595,7 +595,7 @@ static int Create( vlc_va_t *p_va, AVCod
         return err;
 
     /* Only VLD supported */
-    p_va->pix_fmt = PIX_FMT_VAAPI_VLD;
+    p_va->pix_fmt = AV_PIX_FMT_VAAPI_VLD;
     p_va->setup = Setup;
     p_va->get = Get;
     p_va->release = Release;
--- vlc-2.2.1.orig/modules/codec/avcodec/vda.c
+++ vlc-2.2.1/modules/codec/avcodec/vda.c
@@ -145,7 +145,7 @@ static int Open( vlc_va_t *external, AVC
 
     external->sys = p_va;
     external->description = "VDA";
-    external->pix_fmt = PIX_FMT_VDA_VLD;
+    external->pix_fmt = AV_PIX_FMT_VDA_VLD;
     external->setup = Setup;
     external->get = Get;
     external->release = Release;
--- vlc-2.2.1.orig/modules/codec/avcodec/video.c
+++ vlc-2.2.1/modules/codec/avcodec/video.c
@@ -108,8 +108,8 @@ static int lavc_GetFrame(struct AVCodecC
 static int  ffmpeg_GetFrameBuf    ( struct AVCodecContext *, AVFrame * );
 static void ffmpeg_ReleaseFrameBuf( struct AVCodecContext *, AVFrame * );
 #endif
-static enum PixelFormat ffmpeg_GetFormat( AVCodecContext *,
-                                          const enum PixelFormat * );
+static enum AVPixelFormat ffmpeg_GetFormat( AVCodecContext *,
+                                          const enum AVPixelFormat * );
 
 static uint32_t ffmpeg_CodecTag( vlc_fourcc_t fcc )
 {
@@ -223,7 +223,7 @@ int InitVideoDec( decoder_t *p_dec, AVCo
     p_sys->p_codec = p_codec;
     p_sys->i_codec_id = i_codec_id;
     p_sys->psz_namecodec = psz_namecodec;
-    p_sys->p_ff_pic = avcodec_alloc_frame();
+    p_sys->p_ff_pic = av_frame_alloc();
     p_sys->b_delayed_open = true;
     p_sys->p_va = NULL;
     vlc_sem_init( &p_sys->sem_mt, 0 );
@@ -298,7 +298,6 @@ int InitVideoDec( decoder_t *p_dec, AVCo
     if( p_sys->b_direct_rendering )
     {
         msg_Dbg( p_dec, "trying to use direct rendering" );
-        p_sys->p_context->flags |= CODEC_FLAG_EMU_EDGE;
     }
     else
     {
@@ -435,7 +434,7 @@ int InitVideoDec( decoder_t *p_dec, AVCo
     if( ffmpeg_OpenCodec( p_dec ) < 0 )
     {
         msg_Err( p_dec, "cannot open codec (%s)", p_sys->psz_namecodec );
-        avcodec_free_frame( &p_sys->p_ff_pic );
+        av_frame_free( &p_sys->p_ff_pic );
         vlc_sem_destroy( &p_sys->sem_mt );
         free( p_sys );
         return VLC_EGENERIC;
@@ -815,7 +814,7 @@ void EndVideoDec( decoder_t *p_dec )
     wait_mt( p_sys );
 
     if( p_sys->p_ff_pic )
-        avcodec_free_frame( &p_sys->p_ff_pic );
+        av_frame_free( &p_sys->p_ff_pic );
 
     if( p_sys->p_va )
         vlc_va_Delete( p_sys->p_va );
@@ -993,7 +992,7 @@ static picture_t *lavc_dr_GetFrame(struc
     if (GetVlcChroma(&dec->fmt_out.video, ctx->pix_fmt) != VLC_SUCCESS)
         return NULL;
     dec->fmt_out.i_codec = dec->fmt_out.video.i_chroma;
-    if (ctx->pix_fmt == PIX_FMT_PAL8)
+    if (ctx->pix_fmt == AV_PIX_FMT_PAL8)
         return NULL;
 
     int width = frame->width;
@@ -1169,7 +1168,7 @@ static picture_t *ffmpeg_dr_GetFrameBuf(
     if (GetVlcChroma(&p_dec->fmt_out.video, p_context->pix_fmt) != VLC_SUCCESS)
         goto no_dr;
 
-    if (p_context->pix_fmt == PIX_FMT_PAL8)
+    if (p_context->pix_fmt == AV_PIX_FMT_PAL8)
         goto no_dr;
 
     p_dec->fmt_out.i_codec = p_dec->fmt_out.video.i_chroma;
@@ -1204,7 +1203,7 @@ static picture_t *ffmpeg_dr_GetFrameBuf(
             goto no_dr;
     }
 
-    if( p_context->pix_fmt == PIX_FMT_YUV422P )
+    if( p_context->pix_fmt == AV_PIX_FMT_YUV422P )
     {
         if( 2 * p_pic->p[1].i_pitch != p_pic->p[0].i_pitch ||
             2 * p_pic->p[2].i_pitch != p_pic->p[0].i_pitch )
@@ -1302,8 +1301,8 @@ static void ffmpeg_ReleaseFrameBuf( stru
 }
 #endif
 
-static enum PixelFormat ffmpeg_GetFormat( AVCodecContext *p_context,
-                                          const enum PixelFormat *pi_fmt )
+static enum AVPixelFormat ffmpeg_GetFormat( AVCodecContext *p_context,
+                                          const enum AVPixelFormat *pi_fmt )
 {
     decoder_t *p_dec = p_context->opaque;
     decoder_sys_t *p_sys = p_dec->p_sys;
@@ -1314,7 +1313,7 @@ static enum PixelFormat ffmpeg_GetFormat
 
     /* Enumerate available formats */
     bool can_hwaccel = false;
-    for( size_t i = 0; pi_fmt[i] != PIX_FMT_NONE; i++ )
+    for( size_t i = 0; pi_fmt[i] != AV_PIX_FMT_NONE; i++ )
     {
         const AVPixFmtDescriptor *dsc = av_pix_fmt_desc_get(pi_fmt[i]);
         if (dsc == NULL)
@@ -1341,7 +1340,7 @@ static enum PixelFormat ffmpeg_GetFormat
     if( p_va == NULL )
         goto end;
 
-    for( size_t i = 0; pi_fmt[i] != PIX_FMT_NONE; i++ )
+    for( size_t i = 0; pi_fmt[i] != AV_PIX_FMT_NONE; i++ )
     {
         if( p_va->pix_fmt != pi_fmt[i] )
             continue;
--- vlc-2.2.1.orig/modules/video_chroma/swscale.c
+++ vlc-2.2.1/modules/video_chroma/swscale.c
@@ -87,7 +87,7 @@ struct filter_sys_t
 {
     SwsFilter *p_src_filter;
     SwsFilter *p_dst_filter;
-    int i_cpu_mask, i_sws_flags;
+    int i_sws_flags;
 
     video_format_t fmt_in;
     video_format_t fmt_out;
@@ -128,8 +128,6 @@ static int GetParameters( ScalerConfigur
                           const video_format_t *p_fmto,
                           int i_sws_flags_default );
 
-static int GetSwsCpuMask(void);
-
 /* SwScaler point resize quality seems really bad, let our scale module do it
  * (change it to true to try) */
 #define ALLOW_YUVP (false)
@@ -160,9 +158,6 @@ static int OpenScaler( vlc_object_t *p_t
     if( ( p_filter->p_sys = p_sys = malloc(sizeof(filter_sys_t)) ) == NULL )
         return VLC_ENOMEM;
 
-    /* Set CPU capabilities */
-    p_sys->i_cpu_mask = GetSwsCpuMask();
-
     /* */
     i_sws_mode = var_CreateGetInteger( p_filter, "swscale-mode" );
     switch( i_sws_mode )
@@ -231,61 +226,40 @@ static void CloseScaler( vlc_object_t *p
 /*****************************************************************************
  * Helpers
  *****************************************************************************/
-static int GetSwsCpuMask(void)
-{
-    int i_sws_cpu = 0;
-
-#if defined(__i386__) || defined(__x86_64__)
-    if( vlc_CPU_MMX() )
-        i_sws_cpu |= SWS_CPU_CAPS_MMX;
-#if (LIBSWSCALE_VERSION_INT >= ((0<<16)+(5<<8)+0))
-    if( vlc_CPU_MMXEXT() )
-        i_sws_cpu |= SWS_CPU_CAPS_MMX2;
-#endif
-    if( vlc_CPU_3dNOW() )
-        i_sws_cpu |= SWS_CPU_CAPS_3DNOW;
-#elif defined(__ppc__) || defined(__ppc64__) || defined(__powerpc__)
-    if( vlc_CPU_ALTIVEC() )
-        i_sws_cpu |= SWS_CPU_CAPS_ALTIVEC;
-#endif
-
-    return i_sws_cpu;
-}
-
 static void FixParameters( int *pi_fmt, bool *pb_has_a, bool *pb_swap_uv, vlc_fourcc_t fmt )
 {
     switch( fmt )
     {
     case VLC_CODEC_YUV422A:
-        *pi_fmt = PIX_FMT_YUV422P;
+        *pi_fmt = AV_PIX_FMT_YUV422P;
         *pb_has_a = true;
         break;
     case VLC_CODEC_YUV420A:
-        *pi_fmt = PIX_FMT_YUV420P;
+        *pi_fmt = AV_PIX_FMT_YUV420P;
         *pb_has_a = true;
         break;
     case VLC_CODEC_YUVA:
-        *pi_fmt = PIX_FMT_YUV444P;
+        *pi_fmt = AV_PIX_FMT_YUV444P;
         *pb_has_a = true;
         break;
     case VLC_CODEC_RGBA:
-        *pi_fmt = PIX_FMT_BGR32;
+        *pi_fmt = AV_PIX_FMT_BGR32;
         *pb_has_a = true;
         break;
     case VLC_CODEC_ARGB:
-        *pi_fmt = PIX_FMT_BGR32_1;
+        *pi_fmt = AV_PIX_FMT_BGR32_1;
         *pb_has_a = true;
         break;
     case VLC_CODEC_BGRA:
-        *pi_fmt = PIX_FMT_RGB32;
+        *pi_fmt = AV_PIX_FMT_RGB32;
         *pb_has_a = true;
         break;
     case VLC_CODEC_YV12:
-        *pi_fmt = PIX_FMT_YUV420P;
+        *pi_fmt = AV_PIX_FMT_YUV420P;
         *pb_swap_uv = true;
         break;
     case VLC_CODEC_YV9:
-        *pi_fmt = PIX_FMT_YUV410P;
+        *pi_fmt = AV_PIX_FMT_YUV410P;
         *pb_swap_uv = true;
         break;
     default:
@@ -314,7 +288,7 @@ static int GetParameters( ScalerConfigur
     {
         if( p_fmti->i_chroma == VLC_CODEC_YUVP && ALLOW_YUVP )
         {
-            i_fmti = i_fmto = PIX_FMT_GRAY8;
+            i_fmti = i_fmto = AV_PIX_FMT_GRAY8;
             i_sws_flags = SWS_POINT;
         }
     }
@@ -327,9 +301,9 @@ static int GetParameters( ScalerConfigur
      * Without SWS_ACCURATE_RND the quality is really bad for some conversions */
     switch( i_fmto )
     {
-    case PIX_FMT_ARGB:
-    case PIX_FMT_RGBA:
-    case PIX_FMT_ABGR:
+    case AV_PIX_FMT_ARGB:
+    case AV_PIX_FMT_RGBA:
+    case AV_PIX_FMT_ABGR:
         i_sws_flags |= SWS_ACCURATE_RND;
         break;
     }
@@ -403,13 +377,13 @@ static int Init( filter_t *p_filter )
     const unsigned i_fmto_visible_width = p_fmto->i_visible_width * p_sys->i_extend_factor;
     for( int n = 0; n < (cfg.b_has_a ? 2 : 1); n++ )
     {
-        const int i_fmti = n == 0 ? cfg.i_fmti : PIX_FMT_GRAY8;
-        const int i_fmto = n == 0 ? cfg.i_fmto : PIX_FMT_GRAY8;
+        const int i_fmti = n == 0 ? cfg.i_fmti : AV_PIX_FMT_GRAY8;
+        const int i_fmto = n == 0 ? cfg.i_fmto : AV_PIX_FMT_GRAY8;
         struct SwsContext *ctx;
 
         ctx = sws_getContext( i_fmti_visible_width, p_fmti->i_visible_height, i_fmti,
                               i_fmto_visible_width, p_fmto->i_visible_height, i_fmto,
-                              cfg.i_sws_flags | p_sys->i_cpu_mask,
+                              cfg.i_sws_flags,
                               p_sys->p_src_filter, p_sys->p_dst_filter, 0 );
         if( n == 0 )
             p_sys->ctx = ctx;
